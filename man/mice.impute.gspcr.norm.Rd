% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mice.impute.gspcr.norm.R
\name{mice.impute.gspcr.norm}
\alias{mice.impute.gspcr.norm}
\alias{mice.impute.gspcr}
\alias{gspcr}
\title{Imputation by generalized supervised principal component regression}
\usage{
mice.impute.gspcr.norm(
  y,
  ry,
  x,
  wy = NULL,
  thrs = "PR2",
  fit_measure = "BIC",
  nthrs = 10,
  npcs_range = 1:3,
  K = 1,
  ...
)
}
\arguments{
\item{y}{Vector to be imputed}

\item{ry}{Logical vector of length \code{length(y)} indicating the
the subset \code{y[ry]} of elements in \code{y} to which the imputation
model is fitted. The \code{ry} generally distinguishes the observed
(\code{TRUE}) and missing values (\code{FALSE}) in \code{y}.}

\item{x}{Numeric design matrix with \code{length(y)} rows with predictors for
\code{y}. Matrix \code{x} may have no missing values.}

\item{wy}{Logical vector of length \code{length(y)}. A \code{TRUE} value
indicates locations in \code{y} for which imputations are created.}

\item{thrs}{character vector of length 1 storing the type of threshold to be used (see below for available options)}

\item{fit_measure}{character vector of length 1 indicating the type of fit measure to be used in the cross-validation procedure}

\item{nthrs}{numeric vector of length 1 storing the number of threshold values to be used}

\item{npcs_range}{numeric vector defining the numbers of principal components to be used}

\item{K}{numeric vector of length 1 storing the number of folds for the K-fold cross-validation procedure}

\item{...}{Other named arguments.}
}
\value{
Vector with imputed data, the same type as \code{y}, and of length
\code{sum(wy)}
}
\description{
Imputes univariate missing data using generalized supervised principal component regression.
}
\details{
Imputation of \code{y} by supervised principal component regression (Bair, 2006).
The method consists of the following steps:
\enumerate{
\item For a given \code{y} variable under imputation, draw a bootstrap version y*
with replacement from the observed cases \code{y[ry]}, and stores in x* the
corresponding values from \code{x[ry, ]}.
\item Compute bivariate association measure \eqn{\theta} between the observed part of the variable under and every potential predictor in the data.
\item Collect all the predictors with \eqn{\theta} higher than some threshold \eqn{\theta_t} and define them as the active set of predictors.
\item Regress \code{y*} on the Principal components computed on the active set.
\item Calculate the estimated residual standard error \code{sigma} based on the residuals obtained from the PC regression and \code{npcs - 1} degrees of freedom.
\item Obtain predicted values for \code{y} based on the fitted PC regression
and the new data \code{x[wy, ]}
\item Obtain imputations by adding noise scaled by \code{sigma} to these
predictions.
}

The user specifies a number of association values to be checked as threshold values and a range of number of components to be checked.
Then, the range between the minimum and maximum value the bivairate association measure between y and the x is divided into equally spaced steps to produce the desired number of association measures.
Every association measure value is used to define a different active set.
For every active set, all requested PCs are computed and used to predict the dependent variable. If the sets npcs to 1, 3, and 5, then the dependent variable is regressed on 1 component, then on 1 to 3 components and finally on 1 to 5 components.
The combination of active set and npcs that returns the optimal value of a given fit measure is then selected.
This selection of the threshold value \eqn{\theta_t} and the number of components Q can be done through K-fold cross-validation by setting the value of the folds to anything larger than 1.

For details on the admissible values for \code{thrs}, \code{npcs_range}, and \code{fit_measure} consult the help file for the underlying gspcr engine [gspcr::cv_gspcr()].

The user can specify a \code{predictorMatrix} in the \code{mice} call
to define which predictors are provided to this univariate imputation method.
Therefore, users may force the exclusion of a predictor from a given
imputation model by specifying a \code{0} entry.
However, a non-zero entry does not guarantee the variable will be used,
as this decision is ultimately made based on the k-fold cross-validation
procedure.
}
\references{
Bair, E., Hastie, T., Paul, D., & Tibshirani, R. (2006). Prediction by
supervised principal components. Journal of the American Statistical
Association, 101(473), 119-137.
}
\seealso{
Other univariate imputation functions: 
\code{\link{mice.impute.cart}()},
\code{\link{mice.impute.gspcr.logreg}()},
\code{\link{mice.impute.gspcr.polr}()},
\code{\link{mice.impute.gspcr.polyreg}()},
\code{\link{mice.impute.lasso.logreg}()},
\code{\link{mice.impute.lasso.norm}()},
\code{\link{mice.impute.lasso.select.logreg}()},
\code{\link{mice.impute.lasso.select.norm}()},
\code{\link{mice.impute.lda}()},
\code{\link{mice.impute.logreg.boot}()},
\code{\link{mice.impute.logreg}()},
\code{\link{mice.impute.mean}()},
\code{\link{mice.impute.midastouch}()},
\code{\link{mice.impute.mnar.logreg}()},
\code{\link{mice.impute.mpmm}()},
\code{\link{mice.impute.norm.boot}()},
\code{\link{mice.impute.norm.nob}()},
\code{\link{mice.impute.norm.predict}()},
\code{\link{mice.impute.norm}()},
\code{\link{mice.impute.pmm}()},
\code{\link{mice.impute.polr}()},
\code{\link{mice.impute.polyreg}()},
\code{\link{mice.impute.quadratic}()},
\code{\link{mice.impute.rf}()},
\code{\link{mice.impute.ri}()}
}
\author{
Edoardo Costantini, 2022
}
\concept{univariate imputation functions}
\keyword{imputation}
